@page "/compose/"
@using uiExp.Shared
@inject HttpClient Http
@using System.Net.Http
@layout EmptyLayout

@code{


        public String getClass(Boolean left)
        {
            if (left)
                return ("message message-left aos-init");
            else
                return ("message message-right aos-init");

        }

        public String getAlign(Boolean left)
        {
            if (left)
                return "left";
            else
                return "right";
        }

        public String getConversant(bool even, Conversation conversation)
        {

            if (even)
                return conversation.Conversants.First().GetName();
            else
                return conversation.Conversants.Last().GetName();
        }

        //static String[] testlist = new String[] { "eli:", "helloworld", "kush:", "hello eli" };
        //Conversation convo => LoadDms.InboxList[getConversationNum()].GetConvo();//LoadConvos.linesList[1]

        public void ShowData()
        {
            Console.WriteLine("hello");
            // var stringWhole = String.Concat(LoadConvos.ConvoList[getConversationNum()]);
            // Console.WriteLine(stringWhole); //this will print a json of the feed object's properties/values to the console
        }

    private int i = 0;
    private string TopFadeOffset = "-100";
    private string BottomFadeOffset = "100";
    private string TopFadeOutAnchorP = "center-top";
    private string FadeInAnchorP = "center-bottom";
    private bool justAddedRecipient = false;
    private bool containsAllPeople = true;
    private string recipientInputPlaceholder = "Send to...";

    ElementReference recipientInputDiv;

    private string recipientInput = "";
    private bool focusedRecipient = false;
    private List<Hashtag> displayTags = new List<Hashtag>();
    private List<User> displayUsers = new List<User>();
    private List<Reciever> recipientList = new List<Reciever>();
    private PrivateMessage convo = new PrivateMessage();

    public List<Hashtag> GetTags()
    {
        List<Hashtag> Tags = new List<Hashtag>();
        if (!(recipientInput == ""))
        {
            var chars = recipientInput.Length;
            foreach (var hashtag in Hashtags.Tags)
            {
                var tagLength = hashtag.Tag.Length;
                if (!(chars > tagLength))
                {
                    if (String.Equals(hashtag.Tag.Substring(0, chars).ToLower(), recipientInput.ToLower()))
                    {
                        Tags.Add(hashtag);
                    }
                }
            }
        }
        return Tags;

    }
    public List<User> GetPeople()
    {
        List<User> People = new List<User>();
        if (!(recipientInput == ""))
        {

            var chars = recipientInput.Length;
            foreach (var person in Users.List)
            {
                var nameLength = person.GetName().Length;
                if (!(chars > nameLength))
                {
                    //Console.WriteLine("name substring: " + person.GetName().Substring(0, chars));
                    if (String.Equals(person.GetName().Substring(0, chars).ToLower(), recipientInput.ToLower()))
                    {
                        //  Console.WriteLine("name == input: "+recipientInput);
                        People.Add(person);
                    }
                }

            }
        }
        return People;
    }

    public string GetTagString(Hashtag tag)
    {
        return "#" + tag.Tag;
    }

    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            //initialize event listener
            await JSRuntime.InvokeVoidAsync("initKeypressListener", recipientInputRef);
        }
    }
    public void checkState()
    {
        Console.WriteLine("focus top: " + focusedRecipient);
        Console.WriteLine("recipientInput: " + recipientInput);
    }
    public void focusTop()
    {
        focusedRecipient = true;
        Console.WriteLine("focused top");
    }
    public void blurTop()
    {
        //focusedRecipient = false;
        Console.WriteLine("un focused top");
    }
    public void topInput()
    {
        //could improve efficiency by only calling these when recipientInput is changed
        displayTags = GetTags();
        displayUsers = GetPeople();
        //Resize(recipientInputRef, false);
        Console.WriteLine("top input");
    }
    public void addTag(Hashtag tag)
    {

        if (!recipientsInList)
        {
            recipientInputPlaceholder = "Add more recipients....";
        }
        recipientList.Add(new Reciever(tag));
        recipientsInList = true;
        recipientInput = "";
        selectedR = -1;
        rSelected = false;

        justAddedRecipient = true;
        containsAllPeople = false;

        focus(recipientInputRef);
    }
    public void addPerson(User person)
    {

        if (!recipientsInList)
        {
            recipientInputPlaceholder = "Add more recipients....";
        }

        recipientList.Add(new Reciever(person));
        recipientsInList = true;
        recipientInput = "";
        var peopleRecievers = GetUsers(recipientList);
        convo = LoadDms.GetPm(peopleRecievers);
        DumpityDump.Dump(peopleRecievers);
        DumpityDump.Dump(convo.GetConvo().Conversants);



        justAddedRecipient = true;
        focus(recipientInputRef);


    }
    private List<User> GetUsers(List<Reciever> recipients)
    {
        var list = new List<User>();
        foreach (var r in recipients)
        {
            if (r.Type == 1)
            {
                Console.WriteLine("adding person");
                list.Add(r.Person);
            }
            else
            {
                Console.WriteLine("not adding person");
            }
        }
        return list;
    }

    public bool recipientsInList = false;
    private bool recipientHighlighted = false;
    private bool recipientInputEmpty = false;

    async Task doNothingTop(KeyboardEventArgs e)
    {
        await JSRuntime.InvokeVoidAsync("pDefault", e);
    }

    private void detectKeyTop(KeyboardEventArgs e)
    {
        Console.WriteLine("key pressed: " + e.Key);


        if (e.Key == "Backspace")
        {
            if (recipientsInList && recipientInput == "")
            {
                if (recipientHighlighted)
                {
                    if (recipientList.Count == 1)
                        recipientsInList = false;
                    recipientList.RemoveAt(recipientList.Count - 1);
                    recipientHighlighted = false;
                }
                else
                {
                    recipientHighlighted = true;
                }
            }
        }
        else if (e.Key == "ArrowDown")
        {
            Console.WriteLine("selected R pre adjust: " + selectedR);

            rSelected = true;
            if (selectedR < GetNumSuggestions() - 1)
                selectedR++;
            else
                selectedR = 0;
            Console.WriteLine("selected R post adjust: " + selectedR);

        }
        else if (e.Key == "ArrowUp")
        {
            rSelected = true;
            if (selectedR == -1)
                selectedR = GetNumSuggestions() - 1;
            else
                selectedR--;
        }
        else if (e.Key == "Enter")
        {
            if (rSelected == true)
            {
                AddRecipient(selectedR);
            }
            else
            {
                if (recipientsInList && recipientInput == "")
                {
                    focusSlow(messageInputRef);
                }
            }
        }
        else if (recipientHighlighted) //thus written, arrow down or enter will not remove delete highlight. all other key actions will
        {
            recipientHighlighted = false;
        }

        if (!((e.Key == "ArrowDown") | (e.Key == "ArrowUp")))
        {
            rSelected = false;
            selectedR = -1;
        }
        if (!(recipientInput == ""))
        {
            Console.WriteLine("last char input: " + recipientInput.Last());
            Console.WriteLine("last char = empty: " + recipientInput.Last() == "");
            Console.WriteLine("last char = /n" + recipientInput.Last() == "/n");
        }

    }
    private int GetNumSuggestions()
    {
        return displayTags.Count + displayUsers.Count;
    }

    private bool rSelected = false;
    private int selectedR = -1;

    public void AddRecipient(int selected)
    {
        if (selectedR < displayTags.Count)
            addTag(displayTags[selectedR]);
        else
            addPerson(displayUsers[selectedR - displayTags.Count]);
        selectedR = -1;
    }

    async Task focus(ElementReference element)
    {
        await JSRuntime.InvokeAsync<object>("focus", element);
    }
    async Task focusSlow(ElementReference element)
    {
        //await JSRuntime.InvokeVoidAsync("block", e);
        await Task.Delay(5);//this is scrubby but was only way i could get focus to switch to message input on enter without adding a line break in the message box
        await JSRuntime.InvokeVoidAsync("focus", element);
    }
}

<div class="message-tab"
     <div class="message-tabText">
         New Message
     </div>
</div>

<div class="top-row" style="position:fixed; top:15%; height:@getTopHeight()"
    <div class="recipient-container" style="position: fixed; height: @getTopHeight()">
        <div class="recipientText">
            To:
        </div>
        <div class="addedRecipientsList">
            @if (recipientsInList)
        {
            for (int x = 0; x < recipientList.Count - 1; x++)
            {

                    <span class="addedRecipient">
                        @recipientList[x].GetText(),
                    </span>
                }
    if (recipientHighlighted)
    {
                    <span class="addedRecipient" id="r-highlighted">
                        @recipientList[recipientList.Count - 1].GetText()
                    </span>
                }
                else
    {
                    <span class="addedRecipient">
                        @recipientList[recipientList.Count - 1].GetText()
                    </span>
                }
            }
        </div>

        <textarea id="inputTextArea" @ref="recipientInputRef" @onfocus="focusTop" @onblur="blurTop" class="comment-reply-message-input" placeholder="@recipientInputPlaceholder" style="resize:none" @bind="recipientInput" @bind:event="oninput" rows="1" @onkeydown="@(e => detectKeyTop(e))" @onkeyup="() => topInput()" />
          @*@onchange="@((String.IsNullOrEmpty(recipientInput) ? detectDel() : detectDel()))"*@
    </div>
</div>
@*<button @onclick="checkState" class="btn btn-primary" style="top: 200px; position: absolute;"></button>*@

@if (focusedRecipient && !(recipientInput == ""))
{
    <div class="rSuggestions" style="top: 200px;position:fixed">

        @foreach (var tag in displayTags)
        {
            <div class="tagSuggestion" @onclick="() => addTag(tag)" style="background-color:@((displayTags.IndexOf(tag) == selectedR && rSelected) ? "#141414" : "#000000")">
                <span class="hashtagText">
                    @GetTagString(tag)
                </span>
            </div>
        }
        @foreach (var person in displayUsers) //good to use foreach loops to avoid index errors with for loop
        {
            <div class="personSuggestion" @onclick="() => addPerson(person)" style="background-color:@((displayUsers.IndexOf(person)+displayTags.Count == selectedR) ? "#141414" : "#000000")">
                <div class="suggestionImage">
                    <img src="@person.GetImg()" class="profile-pic" />
                </div>
                <div class="suggestionName">
                    <span>@person.GetName()</span>
                </div>
            </div>
        }
    </div>

}

@if (justAddedRecipient && (!(convo.GetConvo() == null)))
{
    <body id="page" data-aos-easing="ease" data-aos-duration="600" data-aos-delay="0">
        <div class="page-content-pm">
            <section class="aos-init " data-aos-once="false" data-aos-duration="600" id="content-container">
                <div class="messages">
                    @foreach (var group in convo.GetConvo().Groups)
                    {
                        <div class="message-group">
                            <p style="text-align:@getAlign(i % 2 == 0);" data-aos="fade" data-aos-once="false" data-aos-duration="600" data-aos-offset="60" data-aos-anchor-placement="@FadeInAnchorP">
                                <span data-aos="slow-partial-fade" data-aos-duration="600" data-aos-offset="-100px" data-aos-anchor-placement="top-top">
                                    @getConversant(i % 2 == 0, convo.GetConvo())
                                </span>
                            </p>
                            @foreach (var message in group.Messages)
                            {
                                <p class=@getClass(i % 2 == 0) data-aos="fade" data-aos-once="false" data-aos-duration="600" data-aos-offset="@BottomFadeOffset" data-aos-anchor-placement="@FadeInAnchorP">
                                    <span data-aos="out" data-aos-duration="600" data-aos-offset="@TopFadeOffset" data-aos-anchor-placement="@TopFadeOutAnchorP">
                                        @if (@message.Text.Contains("img"))
                                        {
                                            @((MarkupString)@message.Text)
                                        }
                                        else
                                        {
                                            @message.Text
                                        }
                                    </span>
                                </p>
                            }
                        </div>
                        i++;
                    }

                </div>
            </section>
        </div>
    </body>
}

<div class="bottom-row-compose" style="position:fixed; bottom:0; height:@getBottomHeight()">
    <div class="messaging-bottom">
        @if (ShowSelector)
        {
            <i class="material-icons" @onclick="DeployShareConvo">
                camera_alt
                add_box
            </i>
        }

        <div class="input-container" id="messageInput">
            <textarea id="inputTextArea" @ref="messageInputRef" class="comment-reply-message-input" placeholder="@messageInputPlaceholder" style="resize:none" @bind="message" rows="1" @oninput="() => Resize(messageInputRef, true)" />
            <i class="fas fa-arrow-up icon sendButton" @onclick="@sendMessage"></i>
        </div>

    </div>
</div>

@code {
    private bool ShowSelector = true;
    private string message;
    private string messageInputPlaceholder = "Send a line...";
    ElementReference messageInputRef;
    ElementReference recipientInputRef;

    [Inject] IJSRuntime JSRuntime { get; set; }

    double MessageHeight = 0;
    double RecipientHeight = 0;

    public void DeployShareConvo()
    {

    }

    async Task Resize(ElementReference element, bool bottom)
    {
        var result = await JSRuntime.InvokeAsync<object>("resizeText", element);
        if (bottom)
        {
            Double.TryParse(result.ToString(), out MessageHeight);
            Console.WriteLine("bottom height: " + MessageHeight);
        }
        else
        {
            Double.TryParse(result.ToString(), out RecipientHeight);
            Console.WriteLine("top height: " + RecipientHeight);
        }
    }

    private string getBottomHeight()
    {
        if (MessageHeight == 0)
            return "58px";
        else
            return (MessageHeight + 36).ToString() + "px";
    }

    private string getTopHeight()
    {
        if (RecipientHeight == 0)
            return "58px";
        else
            return (RecipientHeight + 36).ToString() + "px";
    }

    public void sendMessage()
    {

    }
}
